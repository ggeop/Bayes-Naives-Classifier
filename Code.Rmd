---
title: "Assignment3 (Bayes Naives Classification)"
author: "ggeop"
date: "April 10, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Questions

###1
```{r}

d1 <- c(1, 0, 0, 1, 0, 0, 0, 1)
d2 <- c(0, 1, 0, 1, 1, 0, 0, 0)
d3 <- c(0, 0, 1, 0, 0, 0, 1, 0)
d4 <- c(0, 0, 0, 1, 0, 0, 0, 0)
d5 <- c(0, 0, 0, 0, 0, 0, 1, 0)
d6 <- c(0, 0, 0, 1, 0, 1, 0, 1)
d7 <- c(0, 0, 1, 0, 0, 1, 0, 1)
d8 <- c(1, 0, 0, 0, 0, 0, 0, 1)
d9 <- c(0, 0, 0, 0, 0, 1, 0, 1)
d10 <- c(1, 1, 0, 0, 0, 1, 0, 1)
nb_df <- as.data.frame(rbind(d1,d2,d3,d4,d5,d6,d7,d8,d9,d10))
names(nb_df) <- c("BadCredit", "HasStableJob", "OwnsHouse", "BigLoan",
"HasLargeBankAccount", "HasPriorLoans", "HasDependents", "Decision")

```

###2
```{r}
#Create the Class Vector
decision<-nb_df$Decision

#Calculate the propability of the loan accept
p_accept<-sum(decision==0)/length(decision)

#calculate the propability of the loan rejection
p_reject<-sum(decision==1)/length(decision)

#Create a vector with the prior probabilities
priors<-c(p_accept,p_reject)

```


###3
```{r}

aggregate(x=nb_df[c("BadCredit","HasStableJob","OwnsHouse","BigLoan","HasLargeBankAccount","HasPriorLoans","HasDependents")],
          by =nb_df[c("Decision")],
          FUN = function(x){y <- sum(x)/length(x); return(y)}
                  )

```

###4
Because for each row we have the probabilities when the features are ones only and we don't count the zeros;so we don't can have 1 when we add them together.

###5
```{r}

aggregate(x=nb_df[c("BadCredit","HasStableJob","OwnsHouse","BigLoan","HasLargeBankAccount","HasPriorLoans","HasDependents")],
          by =nb_df[c("Decision")],
          FUN = function(x){y <- 1- sum(x)/length(x); return(y)}
                  )
```

###6

The probability is : P(Accept|BadCredit=0) = P(BadCredit=0|Accept)*P(Accept)/P(BadCredit=0) =>
                     P(Accept|BadCredit=0) = 1*0.4/0.7 =>
                     P(Accept|BadCredit=0) = 0.57


In this extreme case, We count only zeros when the loan is accepted; so the likehood of this senario is equals to one and as a result zero in the case of P(Accept|BadCredit=1). Hence, the probability of the P(BadCredit=1|Accept) goes to zero, something very strict which destroy our calculations.

###7

NOTE: There is a typo in the questions and you count again this question as 6 :-)
```{r}
#Calculate again the propabilities
prob_matrix<-aggregate(x=nb_df[c("BadCredit","HasStableJob","OwnsHouse","BigLoan","HasLargeBankAccount","HasPriorLoans","HasDependents")],
          by =nb_df[c("Decision")],
          FUN = function(x){y <- (sum(x)+1)/(length(x)+2); return(y)}
                  )


```

###8
```{r}
classifier<-function(observation,priors, prob_matrix)
  {
    #Delete the Decision column
    observation$Decision<-NULL
    prob_matrix$Decision<-NULL
    
    #Culculate the probability for the Reject Class (C=1)
    p<-c()
    for (i in 1:ncol(observation))
    {
      if (observation[i]==1)
      {
        p[i]<-prob_matrix[2,i]
      }
      else
      {
        p[i]<-1-prob_matrix[2,i]
      }
    } 
    
    prob_reject<-prod(p)*priors[2]
    
    #Culculate the probability for the Accept Class (C=0)
    p<-c()
    for (i in 1:ncol(observation))
    {
      if (observation[i]==1)
      {
        p[i]<-prob_matrix[1,i]
      }
      else
      {
        p[i]<-1-prob_matrix[1,i]
      }
    } 
    
    prob_accept<-prod(p)*priors[1]
   
   #Assign to the highest probability 
    if(prob_accept>prob_reject)
    {
      return(0) 
    }
    else
    {
      return(1)
    }
    
    
}

predict_nb <- function(test_df, priors, prob_matrix) 
{

  predict<-c()
  for (i in 1:nrow(test_df))
  {
    predict[i]<-classifier(test_df[i,],priors, prob_matrix)
  }


  return(predict)
}


```

 
 
###9
```{r}

#Creare the accuracy function
accuracy<-function(test_dataset, predict_values)
{
  count<-0
  for (i in 1:length(test$Decision))
  {
    if (prediction[i] == test$Decision[i])
    {
      count<-count+1
    }
  }
  return(count/length(test$Decision))
}


#We know that we don't have a test dataset, so we take a partition of the original dataset

test<-nb_df[1:3,]
prediction<-predict_nb(test, priors, prob_matrix)

#We calculate the accuracy. It's normal to have accuracy equals to 1 because we run it in the same dataset.

#Calculate the accuracy
accuracy(test,prediction)

```